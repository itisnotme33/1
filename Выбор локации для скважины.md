

# Выбор локации для скважины

Допустим, вы работаете в добывающей компании «ГлавРосГосНефть». Нужно решить, где бурить новую скважину.

Вам предоставлены пробы нефти в трёх регионах: в каждом 10 000 месторождений, где измерили качество нефти и объём её запасов. Постройте модель машинного обучения, которая поможет определить регион, где добыча принесёт наибольшую прибыль. Проанализируйте возможную прибыль и риски техникой *Bootstrap.*

Шаги для выбора локации:

- В избранном регионе ищут месторождения, для каждого определяют значения признаков;
- Строят модель и оценивают объём запасов;
- Выбирают месторождения с самым высокими оценками значений. Количество месторождений зависит от бюджета компании и стоимости разработки одной скважины;
- Прибыль равна суммарной прибыли отобранных месторождений.


## Загрузка и подготовка данных


```python
import pandas as pd
import numpy as np
import scipy.stats as st
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split

```




```python
data_0 = pd.read_csv('/datasets/geo_data_0.csv')
data_0.info()
data_0.head()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 100000 entries, 0 to 99999
    Data columns (total 5 columns):
     #   Column   Non-Null Count   Dtype  
    ---  ------   --------------   -----  
     0   id       100000 non-null  object 
     1   f0       100000 non-null  float64
     2   f1       100000 non-null  float64
     3   f2       100000 non-null  float64
     4   product  100000 non-null  float64
    dtypes: float64(4), object(1)
    memory usage: 3.8+ MB






<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>f0</th>
      <th>f1</th>
      <th>f2</th>
      <th>product</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>txEyH</td>
      <td>0.705745</td>
      <td>-0.497823</td>
      <td>1.221170</td>
      <td>105.280062</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2acmU</td>
      <td>1.334711</td>
      <td>-0.340164</td>
      <td>4.365080</td>
      <td>73.037750</td>
    </tr>
    <tr>
      <th>2</th>
      <td>409Wp</td>
      <td>1.022732</td>
      <td>0.151990</td>
      <td>1.419926</td>
      <td>85.265647</td>
    </tr>
    <tr>
      <th>3</th>
      <td>iJLyR</td>
      <td>-0.032172</td>
      <td>0.139033</td>
      <td>2.978566</td>
      <td>168.620776</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Xdl7t</td>
      <td>1.988431</td>
      <td>0.155413</td>
      <td>4.751769</td>
      <td>154.036647</td>
    </tr>
  </tbody>
</table>
</div>




```python
data_0.duplicated().sum()
```




    0




```python
data_1 = pd.read_csv('/datasets/geo_data_1.csv')
data_1.info()
data_1.head()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 100000 entries, 0 to 99999
    Data columns (total 5 columns):
     #   Column   Non-Null Count   Dtype  
    ---  ------   --------------   -----  
     0   id       100000 non-null  object 
     1   f0       100000 non-null  float64
     2   f1       100000 non-null  float64
     3   f2       100000 non-null  float64
     4   product  100000 non-null  float64
    dtypes: float64(4), object(1)
    memory usage: 3.8+ MB






<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>f0</th>
      <th>f1</th>
      <th>f2</th>
      <th>product</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>kBEdx</td>
      <td>-15.001348</td>
      <td>-8.276000</td>
      <td>-0.005876</td>
      <td>3.179103</td>
    </tr>
    <tr>
      <th>1</th>
      <td>62mP7</td>
      <td>14.272088</td>
      <td>-3.475083</td>
      <td>0.999183</td>
      <td>26.953261</td>
    </tr>
    <tr>
      <th>2</th>
      <td>vyE1P</td>
      <td>6.263187</td>
      <td>-5.948386</td>
      <td>5.001160</td>
      <td>134.766305</td>
    </tr>
    <tr>
      <th>3</th>
      <td>KcrkZ</td>
      <td>-13.081196</td>
      <td>-11.506057</td>
      <td>4.999415</td>
      <td>137.945408</td>
    </tr>
    <tr>
      <th>4</th>
      <td>AHL4O</td>
      <td>12.702195</td>
      <td>-8.147433</td>
      <td>5.004363</td>
      <td>134.766305</td>
    </tr>
  </tbody>
</table>
</div>




```python
data_1.duplicated().sum()
```




    0




```python
data_2 = pd.read_csv('/datasets/geo_data_2.csv')
data_2.info()
data_2.head()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 100000 entries, 0 to 99999
    Data columns (total 5 columns):
     #   Column   Non-Null Count   Dtype  
    ---  ------   --------------   -----  
     0   id       100000 non-null  object 
     1   f0       100000 non-null  float64
     2   f1       100000 non-null  float64
     3   f2       100000 non-null  float64
     4   product  100000 non-null  float64
    dtypes: float64(4), object(1)
    memory usage: 3.8+ MB






<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>f0</th>
      <th>f1</th>
      <th>f2</th>
      <th>product</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>fwXo0</td>
      <td>-1.146987</td>
      <td>0.963328</td>
      <td>-0.828965</td>
      <td>27.758673</td>
    </tr>
    <tr>
      <th>1</th>
      <td>WJtFt</td>
      <td>0.262778</td>
      <td>0.269839</td>
      <td>-2.530187</td>
      <td>56.069697</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ovLUW</td>
      <td>0.194587</td>
      <td>0.289035</td>
      <td>-5.586433</td>
      <td>62.871910</td>
    </tr>
    <tr>
      <th>3</th>
      <td>q6cA6</td>
      <td>2.236060</td>
      <td>-0.553760</td>
      <td>0.930038</td>
      <td>114.572842</td>
    </tr>
    <tr>
      <th>4</th>
      <td>WPMUX</td>
      <td>-0.515993</td>
      <td>1.716266</td>
      <td>5.899011</td>
      <td>149.600746</td>
    </tr>
  </tbody>
</table>
</div>




```python
data_2.duplicated().sum()
```




    0



Явных дубликатов нет



Удалим из данных ненужный столбец 'id'


```python
data_0 = data_0.drop(['id'], axis=1)
data_1 = data_1.drop(['id'], axis=1)
data_2 = data_2.drop(['id'], axis=1)
```



## Обучение и проверка модели

2.1. Разбейте данные на обучающую и валидационную выборки в соотношении 75:25

Обозначим признаки


```python
features_0 = data_0.drop(['product'], axis=1)
target_0 = data_0['product']

features_1 = data_1.drop(['product'], axis=1)
target_1 = data_1['product']

features_2 = data_2.drop(['product'], axis=1)
target_2 = data_2['product']
```

Разобьем данные и сразу же проконтролируем размеры выборок

Первый регион


```python
features_train_0, features_valid_0, target_train_0, target_valid_0 = train_test_split(features_0, target_0, test_size=0.25, random_state=12345)
```


```python
print(features_train_0.shape)
target_train_0.shape
```

    (75000, 3)





    (75000,)




```python
print(features_valid_0.shape)
target_valid_0.shape
```

    (25000, 3)





    (25000,)



Второй регион


```python
features_train_1, features_valid_1, target_train_1, target_valid_1 = train_test_split(features_1, target_1, test_size=0.25, random_state=12345)
```


```python
print(features_train_1.shape)
target_train_1.shape
```

    (75000, 3)





    (75000,)




```python
print(features_valid_1.shape)
target_valid_1.shape
```

    (25000, 3)





    (25000,)



Третий регион


```python
features_train_2, features_valid_2, target_train_2, target_valid_2 = train_test_split(features_2, target_2, test_size=0.25, random_state=12345)
```


```python
print(features_train_2.shape)
target_train_2.shape
```

    (75000, 3)





    (75000,)




```python
print(features_valid_2.shape)
target_valid_2.shape
```

    (25000, 3)





    (25000,)





2.2. Обучите модель и сделайте предсказания на валидационной выборке.

2.3. Сохраните предсказания и правильные ответы на валидационной выборке.


```python
model_0 = LinearRegression()
model_0.fit(features_train_0,target_train_0)
predictions_0 = model_0.predict(features_valid_0)

```


```python
model_1 = LinearRegression()
model_1.fit(features_train_1,target_train_1)
predictions_1 = model_1.predict(features_valid_1)

```


```python
model_2 = LinearRegression()
model_2.fit(features_train_2,target_train_2)
predictions_2 = model_2.predict(features_valid_2)

```

2.4. Напечатайте на экране средний запас предсказанного сырья и RMSE модели.


```python
stock_mean_0 = predictions_0.mean()
print(stock_mean_0)

rmse_0 = mean_squared_error(target_valid_0, predictions_0)**0.5
rmse_0
```

    92.59256778438035





    37.5794217150813



Средний запас предсказанного сырья в первом регионе - 92.59 тыс баррелей, rmse - 37.58


```python
stock_mean_1 = predictions_1.mean()
print(stock_mean_1)

rmse_1 = mean_squared_error(target_valid_1, predictions_1)**0.5
rmse_1
```

    68.728546895446





    0.893099286775617



Средний запас предсказанного сырья во втором регионе - 68.73 тыс баррелей, rmse - 0.89


```python
stock_mean_2 = predictions_2.mean()
print(stock_mean_2)

rmse_2 = mean_squared_error(target_valid_2, predictions_2)**0.5
rmse_2
```

    94.96504596800489





    40.02970873393434



Средний запас предсказанного сырья в третьем регионе - 94.97 тыс баррелей, rmse - 40.03



2.5. Проанализируйте результаты.

Лучше всего модель предсказала запасы во втором регионе, rmse меньше единицы, однако именно здесь запасы сырья наименьшие



## Подготовка к расчёту прибыли

 3.1. Все ключевые значения для расчётов сохраните в отдельных переменных.


```python
income = 450000 #доход
places = 500 #точки
best_places = 200 #лучшие точки
budget = 10000000000 #бюджет
```



3.2. Рассчитайте достаточный объём сырья для безубыточной разработки новой скважины. Сравните полученный объём сырья со средним запасом в каждом регионе. 


```python
minimum = budget / income / best_places
minimum
```




    111.11111111111111





Минимум запасов  каждой скважины для безубыточной разработки - 111.11 тыс баррелей


```python
region = budget / income
region
```




    22222.222222222223



Средний объем нефти на регион - 22222.22 млн баррелей

Рассчитаем cредний запас нефти по регионам


```python
print(data_0['product'].mean())
print(data_1['product'].mean())
print(data_2['product'].mean())
```

    92.50000000000001
    68.82500000000002
    95.00000000000004


Cредний запас сырья в первом регионе - 92.5 тыс баррелей,
 во втором регионе - 68.83 тыс баррелей,
 в третьем регионе - 95 тыс баррелей

Вывод: средний объем запасов сырья в каждом регионе меньше значения окупаемости




## Расчёт прибыли и рисков 

4.1. Напишите функцию для расчёта прибыли по выбранным скважинам и предсказаниям модели

Преобразуем признаки и предсказания в Series


```python
target_valid_0 = pd.Series(target_valid_0).reset_index(drop=True)
predictions_0 = pd.Series(predictions_0).reset_index(drop=True)

target_valid_1 = pd.Series(target_valid_1).reset_index(drop=True)
predictions_1 = pd.Series(predictions_1).reset_index(drop=True)

target_valid_2 = pd.Series(target_valid_2).reset_index(drop=True)
predictions_2 = pd.Series(predictions_2).reset_index(drop=True)
```




```python
def profit(target, predictions, best_places):
    preds_sorted = predictions.sort_values(ascending=False)
    best = target[preds_sorted.index][:best_places]
    return income * best.sum() - budget
```




```python
profit(target_valid_1, predictions_1, best_places)
```




    2415086696.681511



4.2. Примените технику Bootstrap с 1000 выборок, чтобы найти распределение прибыли.

4.3. Найдите среднюю прибыль, 95%-й доверительный интервал и риск убытков. Убыток — это отрицательная прибыль.


```python
target = [target_valid_0, target_valid_1, target_valid_2]
predictions = [predictions_0, predictions_1, predictions_2]
regions = ['Первый регион', 'Второй регион', 'Третий регион']

state = np.random.RandomState(12345)

for i in range(3):
    values = []
    for k in range(1000):
        target_subsample = target[i].sample(n=places, replace=True, random_state=state)
        predictions_subsample = predictions[i].loc[target_subsample.index]
        values.append(profit(target_subsample.reset_index(drop=True), predictions_subsample.reset_index(drop=True), best_places))

    values = pd.Series(values)
    lower = values.quantile(0.025)
    upper = values.quantile(0.975)

    mean = values.mean()
    
    risk = sum(values < 0) / values.count() * 100
    
    print(regions[i])
    print('Средняя прибыль -', mean)
    print('95%-доверительный интервал', "от", lower, "до", upper)
    print('Риск убытков -', risk, "%")
```

    Первый регион
    Средняя прибыль - 396164984.8023711
    95%-доверительный интервал от -111215545.89049526 до 909766941.5534226
    Риск убытков - 6.9 %
    Второй регион
    Средняя прибыль - 461155817.2772397
    95%-доверительный интервал от 78050810.7517417 до 862952060.2637234
    Риск убытков - 0.7000000000000001 %
    Третий регион
    Средняя прибыль - 392950475.17060447
    95%-доверительный интервал от -112227625.37857565 до 934562914.5511636
    Риск убытков - 6.5 %




Вывод: по итогам исследования видим, что только во втором регионе риск убытков менее нужных нам 2.5%, также доверительный интервал тут имеет положительные значения и средняя прибыль наивысшая

